<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Api-Development on Damian Galarza | Software Engineering &amp; AI Consulting</title><link>https://damiangalarza.com/tags/api-development/</link><description>Recent content in Api-Development on Damian Galarza | Software Engineering &amp; AI Consulting</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 26 Jan 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://damiangalarza.com/tags/api-development/atom.xml" rel="self" type="application/rss+xml"/><item><title>Take Control of Your HTTP Caching in Rails</title><link>https://damiangalarza.com/posts/2015-01-26-take-control-of-your-http-caching-in-rails/</link><pubDate>Mon, 26 Jan 2015 00:00:00 +0000</pubDate><guid>https://damiangalarza.com/posts/2015-01-26-take-control-of-your-http-caching-in-rails/</guid><description>&lt;p&gt;This post was originally published on the &lt;a href="https://thoughtbot.com/blog/take-control-of-your-http-caching-in-rails"&gt;thoughtbot blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Rails &lt;code&gt;fresh_when&lt;/code&gt; method is a powerful tool for conditionally caching resources via HTTP. However there are some pitfalls. For one, &lt;code&gt;fresh_when&lt;/code&gt; only supports the default render flow in a controller; if a client&amp;rsquo;s cache is not fresh, it will just render the related view. We cannot utilize things like &lt;code&gt;render json:&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, Rails provides us with more tools to work with HTTP conditional caching. Some of the basics behind HTTP conditional caching are assumed in this post. If you haven&amp;rsquo;t already, or you just need a refresher take a look at &lt;a href="https://damiangalarza.com/posts/2014-11-25-introduction-to-conditional-http-caching-with-rails/"&gt;Introduction to Conditional HTTP Caching with Rails&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Scaling JSON APIs in Rails using ActiveModel::Serializers, Key-Based Caching, and Rack::Cache</title><link>https://damiangalarza.com/posts/scaling-json-apis-in-rails/</link><pubDate>Sun, 03 Nov 2013 00:00:00 +0000</pubDate><guid>https://damiangalarza.com/posts/scaling-json-apis-in-rails/</guid><description>A guide on building high-scale JSON APIs in Rails using ActiveModel::Serializers, Key-Based Caching, and Rack::Cache. This post covers organizing APIs, leveraging HTTP caching, and ensuring high scalability.</description></item><item><title>NewRelic RPM with ActionController::Metal</title><link>https://damiangalarza.com/posts/2012-09-05-newrelic-rpm-with-actioncontroller-metal/</link><pubDate>Wed, 05 Sep 2012 00:00:00 +0000</pubDate><guid>https://damiangalarza.com/posts/2012-09-05-newrelic-rpm-with-actioncontroller-metal/</guid><description>Get NewRelic RPM request instrumentation while using ActionController::Metal</description></item><item><title>AssetPath with ActionController::Metal</title><link>https://damiangalarza.com/posts/2012-08-13-assetpath-with-actioncontroller-metal/</link><pubDate>Mon, 13 Aug 2012 02:26:53 +0000</pubDate><guid>https://damiangalarza.com/posts/2012-08-13-assetpath-with-actioncontroller-metal/</guid><description>Getting proper asset paths with the asset pipeline while working with a controller which doesn&amp;rsquo;t inherit from ActionController::Base can be a bit confusing. Learn how to get it working here.</description></item><item><title>Simple Sinatra Service Proxy</title><link>https://damiangalarza.com/posts/2012-04-02-simple-sinatra-service-proxy/</link><pubDate>Mon, 02 Apr 2012 00:00:00 +0000</pubDate><guid>https://damiangalarza.com/posts/2012-04-02-simple-sinatra-service-proxy/</guid><description>Use Sinatra to rapidly build a proxy for a service when you can&amp;rsquo;t make cross-origin AJAX requests in development.</description></item></channel></rss>